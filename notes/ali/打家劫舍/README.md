#正文：
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

##示例 1:

###输入: 
[1,2,3,1]
###输出: 
4
###解释: 
偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。

###示例 2:

###输入: 
[2,7,9,3,1]
###输出: 
12
###解释: 
偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。

偷窃到的最高金额 = 2 + 9 + 1 = 12 。

##分析
很明显的是动态规划题。对于动态规划题就是找他的动态规划方程，也就是找规律。
###拿示例1讲解：
[1,2,3,1]

我们会发现我们找的就是当前房屋金额和之前的间隔房屋最大金额与相邻房屋最大金额的最大值。

使用nums数组存储房屋的金额数，使用一个数组arr作为偷到该房屋最大金额数的存储，长度等于房屋数。对于arr[0]就是他自己的金额数为nums[0]=1，对于arr[1]呢，就是nums[0]和nums[1]的较大者，那么对于arr[i]，我们能得到的最大金额是多少呢？就是它的金额数和间隔的房屋最大金额数与它相邻的房屋最大金额数。即：num[i]+arr[i-2]与arr[i-1]的较大者。

###动态规划方程为：
```java
arr[i] = Math.max(nums[i]+arr[i-2],arr[i-1]);
```
##代码

```java
public int rob(int[] nums) {
    int len = nums.length;
    if (nums.length == 0) {
        return 0;
    } else if (nums .length == 1) {
        return nums[0];
    }
    int [] arr = new int[len];
    arr[0] = nums[0];
    arr[1] = nums[1] > nums[0] ? nums[1] : nums[0];
    for (int i = 2; i < len; i++) {
        arr[i] = Math.max(nums[i]+arr[i-2],arr[i-1]);
    }
    return arr[len-1];
}
```
